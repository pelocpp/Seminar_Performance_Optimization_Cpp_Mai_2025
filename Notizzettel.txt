Performance - Optimierung C++
=============================

Peter Loos

30+ Jahren

C/C++ , C#, Java, Mobile Programming (Java), Flutter, JavaScript 

// Python

2 Tools:

== Github

https://github.com/pelocpp

== Visual Studio 2022


=============================

Ab 12.30 

=============================

Erwartungen:

Was sind meine Erwartungen

Was MUSS drin sein

Eher nicht

C++ Features, die gerade nicht erwähnt wurden

smart_ptr

=============================

Inhalt:

Tool FramePro

memset , ....

STL: Standard C++ Bibliothek.

Container: 

   std::vector, std::queue,

   Hash-Tabelle: std::map // std::unordered_map

   Key / Value Pairs: Dictionary

STL-Algorithmen:

   Durchlaufen / Traversieren eines Containers.
   Suchen
   Vorbelegen
   Entfernen

   Transformieren




=============================

ToDo - Liste:

std::array, std::span ....      Robustheit // Performanz

auto  (Verlust von const und Referenz, std::uint8_t)

auto: Bei Lambdas geht es nicht anders :)

STL: Eher nicht // eher doch:

Lambda: Intern realisiert sind  // mutable

Cpp Insights

=============================

std::string_view
=================

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/StringView/StringView.md

std::string:          Wo liegen die Zeichen: HEAP

const char* s = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";   NICHT AM HEAP !!!!!!!!!!!


std::string_view:  Verwaltet:

i)  Pointer
ii) Länge


std::string_view ist ein NON-OWNING Container: 

Er verwaltet eine Adresse + Länge: Adresse muss gültig sein.

=============================================================

Online Compiler:

Wandbox.org

https://wandbox.org/

=============================================================

std::initializer_list

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/InitializerList/InitializerList.md

Daten:

std::initializer_list:      <=== Stack

std::vector:                <=== Heap


Fazit:
Wenn Daten über einen Methodenaufruf zu transportieren sind
in einem Vektor, dann geht das mit std::initializer_list schneller !!!

Beachte: Die Daten müssen Kopier-Konstruierbar auf dem Stack sein.  

=============================================================

RAII:

Idee: Resources ===> open // close // es geht um das Vergessen des close

Hüllenobjekte:   // Deterministisch

Konstruktor:  open
Destruktor:   close  <=== Nicht vergessen 

=============================================================

constexpr

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/ConstExpr/Constexpr.md


Wie können wir das einsetzen ????

Anwendungsfälle:
Programmierung zur Übersetzungszeit.

Erste Anwendung:
constexpr Lambdas: Ausdrücke im Stile von Makros besser schreiben
Stichwort: IIFE - Immediately Invoked Functional Expression

Zweite Anwendung:
Berechnung von Tabellen:  Beispiel CRC-Polynome und deren Koeffizienten.

=========================================================================

Copy/Move Elision
=================

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/CopyMoveElision/CopyMoveElision.md

Es geht um Zeitersparnis

Es geht um das Vermeiden überflüssiger Kopien

==> Wir können das nicht wirklich direkt selbst programmieren.

Aber wir sollten es kennen !!!

Beispiel: 

Zeile 104 in Datei Topic_Copy_Move_Elision.cpp

i) Rückgabe eines temporären Objekts:

   return Foo(...);

   Copy_Move_Elision  // RVO


i) Rückgabe eines benannten Objekts:

   Foo obj (...);
   return obj;

==> NRVO: Named Return Value Optimization.

Frage:

Foo createData() {
    Foo data{ 1 };
    return data;
}

oder

Foo createData() {
    Foo data{ 1 };
    return std::move(data);     // NIEMALS !!!!!!!!!!!!!!!!!!!!!!!!
}

Why: Der Compiler ist derjenige, der immer den besten / optimalen
Code erzeugt - wir sollten nicht klüger sein.

=========================================================================

Frage:

Stack versus Heap.

Wo sollten Variablen liegen: Stack oder Heap.

Nicht zu vergessen:  Es gibt auch globale Variablen.

Heap:  Pointer (Raw, Smart) ==> von Methode zu Methode weiterreichen.

Es gibt auch globale Variablen:

Sind im ganzen Programm verfügbar: Pro // Contra.

Sind nur in einer Datei verfügbar: static

(im .obj wird vermerkt, dass diese Variable nur in dieser Datei sichtbar ist)


======================================================================

CPU-Cache-Speicher

== Was hat das mit C++ zu tun

== Was hat das mit Performanz zu tun

Matrix:

[1]:    Elapsed time: ca. 167 [milliseconds]

[1]:    Elapsed time: >= 700 [milliseconds]

versus



======================================================================

Parallel Arrays: Beipiel


struct User
{
    std::string m_name;
    std::string m_username;
    std::string m_password;
    std::string m_securityQuestion;
    std::string m_securityAnswer;
    short       m_level{};
    bool        m_isPlaying{};
};

struct Users
{
    struct User
    {
        std::string m_name;
        std::string m_username;
        std::string m_password;
        std::string m_securityQuestion;
        std::string m_securityAnswer;
    } m_users[1000];

    short       m_level[1000];
    bool        m_isPlaying[1000];
}


Aus dem Buch Andrist / Sehr: Parallele Arrays ab Seite ca. 120.

================================================================

STL Container:

std::unorderer_map:


Telefonbuch:  "Mueller" => 345345

std::unordered_map<std::string, size_t>

class User
{
};

std::unordered_map<User, size_t>

ERROR at Compile Time.   => Hash-Funktion fehlt.

===================================================

Überblick STL Algorithmen:

Es werden einfache STL-Algorithmen vorgestellt:

std::fill
std::for_each
std::generate
std::accumulate
std::copy

An Hand von Zeitvergleichen lassen sich elementare Funktionalitäten vergleichen:

== Initialisierung eines STL-Containers mit konstantem Wert.
== Initialisierung eines STL-Containers mit variienden Werten.
== Traversierung eines STL-Containers zur Summenbildung.
== Kopieren eines Containers.

=====================================

Historische Entwurfsentscheidung bei der STL:

Container   <==>   Iteratoren     <==>   Algorithmen

        std::for_each(
            values.begin(),
            values.end(),
            [](auto& elem) { elem = 123.0; }
        );

API der Algorithmen ziemlich "transparent" zu halten.

Ausnahme:

for_each: Auch in C++

=====================================

Initialisierung eines STL-Containers mit konstantem Wert.

Using a classic for-loop
[1]:    Elapsed time: 128 [milliseconds]
Using an iterator-based for-loop
[1]:    Elapsed time: 15 [milliseconds]
Using std::fill
[1]:    Elapsed time: 19 [milliseconds]
Using std::fill - using execution policy
[1]:    Elapsed time: 18 [milliseconds]
Using std::for_each
[1]:    Elapsed time: 18 [milliseconds]
Using range-based for loop // for_each
[1]:    Elapsed time: 15 [milliseconds]
Using std::generate
[1]:    Elapsed time: 21 [milliseconds]



Warum ist std::fill besser

a) Eine Index-baasierte Loop hat viel MAschinencode

b) std::fill :

A) Kann sehr wohl auf std::memset, std::memcpy, zurückgreifen // abbilden.

oder andere tiefer-liegende Optionen.


==================================================================


Unterschied std::for_each // std::generate

==================================================================

Frage:

Was ist bei std::memset das Problem:

std::memset
 C++ Text processing library Null-terminated byte strings 
Defined in header <cstring>
void* memset( void* dest, int ch, std::size_t count )

int x;  // soll 4 byte groß sein.

x = 123;


memset (&x, 123, 4);  // Fehler // Problem


==================================================================

Vorbelegung:

Geht auch mit "  =  { } " gut bei Containern und dem Null-Wert

            std::array<double, 10000> values = { };
00007FF648389BB0  lea         rax,[rbp+30h]  
00007FF648389BB4  mov         rdi,rax  
00007FF648389BB7  xor         eax,eax  
00007FF648389BB9  mov         ecx,13880h  
00007FF648389BBE  rep stos    byte ptr [rdi]  

            std::println();
00007FF648389BC0  call        std::println<0> (07FF64837296Ah)  
00007FF648389BC5  nop  


===============================================================

GCC:
====

Copying: Using a classic for-loop
[1]: 	Elapsed time: 11 [milliseconds]
Copying: Using an iterator-based for-loop
[1]: 	Elapsed time: 4 [milliseconds]
Standard Algorithm - std::copy:
[1]: 	Elapsed time: 1 [milliseconds]
Using std::copy - using execution policy
[1]: 	Elapsed time: 1 [milliseconds]
Using std::memcpy
[1]: 	Elapsed time: 0 [milliseconds]

Visual C++:
===========

Copying: Using a classic for-loop
[1]:    Elapsed time: 375 [milliseconds]
Copying: Using an iterator-based for-loop
[1]:    Elapsed time: 426 [milliseconds]
Standard Algorithm - std::copy:
[1]:    Elapsed time: 191 [milliseconds]
Using std::copy - using execution policy
[1]:    Elapsed time: 193 [milliseconds]
Using std::memcpy
[1]:    Elapsed time: 192 [milliseconds]

Zwischenfazit:   Go - for - STL

================================================

auto:

Wo tritt es in Erscheinung:

A) Deklaration von Variablen:

      auto n = 123;

      Type Deduction // Typableitung

B) Deklaration von Parametern:

   [](auto i) {
       std::print("{} ", i);
   }

  Generische Lambdas // generische Funktion:

  Pro:     Optimaler Maschinencode wird erzeugt
   
           Für int, für double, ....

  Contra:  Sollte Typableitung gut kennen.

C) Als Rückgabetyp von freien Funktionen / Methoden

  ====================================================

  Peformanz:

    void test_func1(int n)
    {
        int m = n;
    }

        int m = n;
00007FF72EE4C6FF  mov         eax,dword ptr [n]  
00007FF72EE4C705  mov         dword ptr [m],eax  

    void test_func2(int& n)
    {
        int m = n;
    }

        int m = n;
00007FF72EE4C740  mov         rax,qword ptr [n]  
00007FF72EE4C747  mov         eax,dword ptr [rax]  
00007FF72EE4C749  mov         dword ptr [m],eax  


// =====================================================

Frage:

Es macht keinen Unterschied, ob Referenz oder Pointer ????

A) Objekt liegt am STACK:  Go for Referenz (Pointer ginge // very C-Stylistic)

void tue_was()
{
    std::string s;
}

B) Objekt liegt am HEAP:   Go for Pointer (geht gar nicht anders)

// ================================================================


auto values = std::vector<int>(10);

std::iota(
    values.begin(),
    values.end(),
    1
);

std::for_each(
    values.begin(),
    values.end(),
    [](auto i) { std::print("{} ", i); }
);

STL:  Stilistik:

Programmieren in "Building Blocks"

====================================================

Transformieren:  Umwandeln

STL:   2 Container:

Wollen die Daten des ersten Containers in einem zweiten Container "anders", also mit einem anderen Datentyp
aufbereiten.

ABER:

Quell- und Ziel-Container müssen gleich gross sein.

====================================================

Grundlagen für STL-Algorithmen:
-------------------------------

auto

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/Auto/Auto.md


Lambda

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/Lambda/Lambda.md

Generischer Lambda:

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/GenericFunctions/GenericFunctions.md

====================================================

Warum sind Lambdas wichtig:

Sie können "inline" umgesetzt werden.

Was ist ein Lambda:

Lambda-Funktion  falsch:  Lambda: Objekt

Aufrufbares Objekt // Callable Object

====================================================

Cpp Insights:

https://cppinsights.io/

KEIN Online - Compiler:

Converter: C++ ==> C++

           Original ==> C++: Wie siegt es die Sprache "intern"

// ==========================================================

std::array   STL

C-Style Array

Performanz:  Kein Gewinn.

Robustheit !!!

std::array
std::vector
C-Style Array
std::span

C-Array: Keine Überprüfung der Korrektheit der Indices.

   Debug-Modus: Doch. // Release-Modus: Nein.

CTAD - Class Template Argument Deduction

Robustheit ===> 'at' als Zugriff wirft eine Ausnahme.

  Für Performanz: operator[] wirft keine Ausnahme.

=====================================

    static void printArray(const int* array, size_t size) {

Für die beiden Werte int* array und size_t size
gibt es eine Hüllen:

std::span   Spanne: Von einer Anfangsadresse bis hin zu einer
                    bestimmten Länge

template<typename T>
class span {
    T*   m_data;
    size_t m_count;
public:
    ...
};

Ein std::span ist vergleichbar mit std::string_view.

=====================================

Micro-Benchmarking:  Kleinere Code-Sequenzen.

=====================================

Placement New:

Es geht um den HEAP.

Beispiel:  

std::string* sp = new std::string("ABC");

i)  Es wird Speicher reserviert auf dem Heap (40 Bytes).

ii) Dieser Speicherbereich wird initialisiert / vorbelegt: Durch den Konstruktor.

C++:   Man kann i) und ii) trennen / separat gestalten.


new            ===> Vorbelegung ist bei Objekten dabei.

std::malloc()  ===> Keine Vorbelegung!



