Performance - Optimierung C++
=============================

Peter Loos

30+ Jahren

C/C++ , C#, Java, Mobile Programming (Java), Flutter, JavaScript 

// Python

2 Tools:

== Github

https://github.com/pelocpp

== Visual Studio 2022


=============================

Ab 12.30 

=============================

Erwartungen:

Was sind meine Erwartungen

Was MUSS drin sein

Eher nicht

C++ Features, die gerade nicht erwähnt wurden

smart_ptr

=============================

Inhalt:

Tool FramePro

memset , ....

STL: Standard C++ Bibliothek.

Container: 

   std::vector, std::queue,

   Hash-Tabelle: std::map // std::unordered_map

   Key / Value Pairs: Dictionary

STL-Algorithmen:

   Durchlaufen / Traversieren eines Containers.
   Suchen
   Vorbelegen
   Entfernen

   Transformieren




=============================

ToDo - Liste:

std::array, std::span ....      Robustheit // Performanz

auto  (Verlust von const und Referenz, std::uint8_t)

auto: Bei Lambdas geht es nicht anders :)

STL: Eher nicht // eher doch:

Lambda: Intern realisiert sind

Cpp Insights

=============================

std::string_view
=================

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/StringView/StringView.md

std::string:          Wo liegen die Zeichen: HEAP

const char* s = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";   NICHT AM HEAP !!!!!!!!!!!


std::string_view:  Verwaltet:

i)  Pointer
ii) Länge


std::string_view ist ein NON-OWNING Container: 

Er verwaltet eine Adresse + Länge: Adresse muss gültig sein.

=============================================================

Online Compiler:

Wandbox.org

https://wandbox.org/

=============================================================

std::initializer_list

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/InitializerList/InitializerList.md

Daten:

std::initializer_list:      <=== Stack

std::vector:                <=== Heap


Fazit:
Wenn Daten über einen Methodenaufruf zu transportieren sind
in einem Vektor, dann geht das mit std::initializer_list schneller !!!

Beachte: Die Daten müssen Kopier-Konstruierbar auf dem Stack sein.  

=============================================================

RAII:

Idee: Resources ===> open // close // es geht um das Vergessen des close

Hüllenobjekte:   // Deterministisch

Konstruktor:  open
Destruktor:   close  <=== Nicht vergessen 

=============================================================

constexpr

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/ConstExpr/Constexpr.md


Wie können wir das einsetzen ????

Anwendungsfälle:
Programmierung zur Übersetzungszeit.

Erste Anwendung:
constexpr Lambdas: Ausdrücke im Stile von Makros besser schreiben
Stichwort: IIFE - Immediately Invoked Functional Expression

Zweite Anwendung:
Berechnung von Tabellen:  Beispiel CRC-Polynome und deren Koeffizienten.

=========================================================================

Copy/Move Elision
=================

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/CopyMoveElision/CopyMoveElision.md

Es geht um Zeitersparnis

Es geht um das Vermeiden überflüssiger Kopien

==> Wir können das nicht wirklich direkt selbst programmieren.

Aber wir sollten es kennen !!!

Beispiel: 

Zeile 104 in Datei Topic_Copy_Move_Elision.cpp

i) Rückgabe eines temporären Objekts:

   return Foo(...);

   Copy_Move_Elision  // RVO


i) Rückgabe eines benannten Objekts:

   Foo obj (...);
   return obj;

==> NRVO: Named Return Value Optimization.

Frage:

Foo createData() {
    Foo data{ 1 };
    return data;
}

oder

Foo createData() {
    Foo data{ 1 };
    return std::move(data);     // NIEMALS !!!!!!!!!!!!!!!!!!!!!!!!
}

Why: Der Compiler ist derjenige, der immer den besten / optimalen
Code erzeugt - wir sollten nicht klüger sein.

=========================================================================

Frage:

Stack versus Heap.

Wo sollten Variablen liegen: Stack oder Heap.

Nicht zu vergessen:  Es gibt auch globale Variablen.

Heap:  Pointer (Raw, Smart) ==> von Methode zu Methode weiterreichen.

Es gibt auch globale Variablen:

Sind im ganzen Programm verfügbar: Pro // Contra.

Sind nur in einer Datei verfügbar: static

(im .obj wird vermerkt, dass diese Variable nur in dieser Datei sichtbar ist)


======================================================================

CPU-Cache-Speicher

== Was hat das mit C++ zu tun

== Was hat das mit Performanz zu tun

Matrix:

[1]:    Elapsed time: ca. 167 [milliseconds]

[1]:    Elapsed time: >= 700 [milliseconds]

versus



======================================================================

Parallel Arrays: Beipiel


struct User
{
    std::string m_name;
    std::string m_username;
    std::string m_password;
    std::string m_securityQuestion;
    std::string m_securityAnswer;
    short       m_level{};
    bool        m_isPlaying{};
};

struct Users
{
    struct User
    {
        std::string m_name;
        std::string m_username;
        std::string m_password;
        std::string m_securityQuestion;
        std::string m_securityAnswer;
    } m_users[1000];

    short       m_level[1000];
    bool        m_isPlaying[1000];
}


Aus dem Buch Andrist / Sehr: Parallele Arrays ab Seite ca. 120.

================================================================

STL Container:

std::unorderer_map:


Telefonbuch:  "Mueller" => 345345

std::unordered_map<std::string, size_t>

class User
{
};

std::unordered_map<User, size_t>

ERROR at Compile Time.   => Hash-Funktion fehlt.

===================================================

Überblick STL Algorithmen:

Es werden einfache STL-Algorithmen vorgestellt:

std::fill
std::for_each
std::generate
std::accumulate
std::copy

An Hand von Zeitvergleichen lassen sich elementare Funktionalitäten vergleichen:

== Initialisierung eines STL-Containers mit konstantem Wert.
== Initialisierung eines STL-Containers mit variienden Werten.
== Traversierung eines STL-Containers zur Summenbildung.
== Kopieren eines Containers.

=====================================

Historische Entwurfsentscheidung bei der STL:

Container   <==>   Iteratoren     <==>   Algorithmen

        std::for_each(
            values.begin(),
            values.end(),
            [](auto& elem) { elem = 123.0; }
        );

API der Algorithmen ziemlich "transparent" zu halten.

Ausnahme:

for_each: Auch in C++

=====================================

Initialisierung eines STL-Containers mit konstantem Wert.

Using a classic for-loop
[1]:    Elapsed time: 128 [milliseconds]
Using an iterator-based for-loop
[1]:    Elapsed time: 15 [milliseconds]
Using std::fill
[1]:    Elapsed time: 19 [milliseconds]
Using std::fill - using execution policy
[1]:    Elapsed time: 18 [milliseconds]
Using std::for_each
[1]:    Elapsed time: 18 [milliseconds]
Using range-based for loop // for_each
[1]:    Elapsed time: 15 [milliseconds]
Using std::generate
[1]:    Elapsed time: 21 [milliseconds]



Warum ist std::fill besser

a) Eine Index-baasierte Loop hat viel MAschinencode

b) std::fill :

A) Kann sehr wohl auf std::memset, std::memcpy, zurückgreifen // abbilden.

oder andere tiefer-liegende Optionen.


==================================================================


Unterschied std::for_each // std::generate

==================================================================

Frage:

Was ist bei std::memset das Problem:

std::memset
 C++ Text processing library Null-terminated byte strings 
Defined in header <cstring>
void* memset( void* dest, int ch, std::size_t count )

int x;  // soll 4 byte groß sein.

x = 123;


memset (&x, 123, 4);  // Fehler // Problem


==================================================================

Vorbelegung:

Geht auch mit "  =  { } " gut bei Containern und dem Null-Wert

            std::array<double, 10000> values = { };
00007FF648389BB0  lea         rax,[rbp+30h]  
00007FF648389BB4  mov         rdi,rax  
00007FF648389BB7  xor         eax,eax  
00007FF648389BB9  mov         ecx,13880h  
00007FF648389BBE  rep stos    byte ptr [rdi]  

            std::println();
00007FF648389BC0  call        std::println<0> (07FF64837296Ah)  
00007FF648389BC5  nop  


===============================================================

GCC:
====

Copying: Using a classic for-loop
[1]: 	Elapsed time: 11 [milliseconds]
Copying: Using an iterator-based for-loop
[1]: 	Elapsed time: 4 [milliseconds]
Standard Algorithm - std::copy:
[1]: 	Elapsed time: 1 [milliseconds]
Using std::copy - using execution policy
[1]: 	Elapsed time: 1 [milliseconds]
Using std::memcpy
[1]: 	Elapsed time: 0 [milliseconds]

Visual C++:
===========

Copying: Using a classic for-loop
[1]:    Elapsed time: 375 [milliseconds]
Copying: Using an iterator-based for-loop
[1]:    Elapsed time: 426 [milliseconds]
Standard Algorithm - std::copy:
[1]:    Elapsed time: 191 [milliseconds]
Using std::copy - using execution policy
[1]:    Elapsed time: 193 [milliseconds]
Using std::memcpy
[1]:    Elapsed time: 192 [milliseconds]

Zwischenfazit:   Go - for - STL

